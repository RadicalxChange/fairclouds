---
// dont prerender this component as we need to get fresh data from the api.
export const prerender = false;

import directus from "../lib/directus";
import { readItems } from "@directus/sdk";
import Treemap from "./Treemap.svelte";
import { Image } from "astro:assets";

import horizon from "../images/horizon.png";

// Map settings

// const polygons = await directus.request(
// 	readItems("polygons", {
// 		fields: ["id", "location", "price", { licenses: ["id"] }],
// 	}),
// );

// const drawings = await directus.request(
// 	readItems("drawings", {
// 		fields: ["id", "name", "location", "artist_credit", "image"],
// 	}),
// );

// intersection of a point with drawing polygons
// const intersects = await directus.request(
// 	readItems("drawings", {
// 		fields: ["*"],
// 		filter: {
// 			area: {
// 				_intersects: {
// 					type: "Feature",
// 					properties: {},
// 					geometry: {
// 						coordinates: [-66.09679179594478, -23.722487874932185],
// 						type: "Point",
// 					},
// 				},
// 			},
// 		},
// 	}),
// );
// console.log("INTERSECTION");
// console.log(intersects);

// intersection of a polygon with drawing polygons
// const response = await directus.items("Land").readByQuery({
// 	limit: 100,
// 	fields: ["id", "name", "center", "geometry"],
// 	filter: {
// 		center: {
// 			_intersects: {
// 				type: "Feature",
// 				geometry: {
// 					coordinates: [
// 						[
// 							[168.2947501099543, -17.723682144590242],
// 							[168.2947501099543, -17.727328428851507],
// 							[168.29840874403044, -17.727328428851507],
// 							[168.29840874403044, -17.723682144590242],
// 							[168.2947501099543, -17.723682144590242],
// 						],
// 					],
// 					type: "Polygon",
// 				},
// 			},
// 		},
// 	},
// });
---

<div
	class="w-full h-screen flex flex-col bg-blue-100 items-center justify-center relative"
>
	<canvas class="w-[800px] h-[800px]" id="map"></canvas>
	<!-- <canvas
		class="bg-white border border-black absolute bottom-2 left-2 hidden"
		id="minimap"></canvas> -->
	<!-- <Image
		src={horizon}
		alt=""
		class="absolute bottom-2 right-2 w-screen pointer-events-none h-[25vh] object-fill object-top"
		id="horizon"
	/> -->
	<!-- <Treemap drawings={drawings} client:load /> -->
	<!-- <a class="bg-grey rounded-full px-6 py-2" href="/checkout">Checkout</a> -->
</div>

<script>
	import * as d3 from "d3";
	import * as d3Tile from "d3-tile";

	const tileSize = 256;
	const initialZoom = 3; // Set your desired initial zoom level
	const maxZoom = 9; // Set your maximum zoom level
	const minZoom = 1; // Set your minimum zoom level

	// Set up the canvas element
	const canvas = document.getElementById("map") as HTMLCanvasElement;
	const width = 800;
	const height = 800;
	const context = canvas.getContext("2d");

	// Set up the projection and zoom
	const projection = d3
		.geoMercator()
		.scale(((1 << initialZoom) * tileSize) / (2 * Math.PI));
	// .translate([width / 2, height / 2]);

	const tiler = d3Tile.tile().extent([
		[0, 0],
		[width, height],
	]);

	const zoom = d3
		.zoom()
		.scaleExtent([1 << 8, 1 << 22])
		.extent([
			[0, 0],
			[width, height],
		])
		.on("zoom", (event) => zoomed(event.transform));

	d3.select(canvas)
		.call(zoom)
		.call(
			zoom.transform,
			d3.zoomIdentity.translate(width >> 1, height >> 1).scale(1 << 10),
		);

	function zoomed(transform) {
		// console.log(event.transform);
		const tiles = tiler(transform);

		console.log(tiles);

		// projection
		// 	.scale(transform.k / (2 * Math.PI))
		// 	.translate([transform.x, transform.y]);

		context.clearRect(0, 0, width, height);
		context.save();
		context.scale(tiles.scale, tiles.scale);
		context.translate(...tiles.translate);

		tiles.forEach((d) => {
			const [x, y, z] = d;
			const tileX = x * tileSize;
			const tileY = y * tileSize;
			const tileZ = z;
			const imgSrc = `/tiles/${tileZ}/${tileX / tileSize}_${tileY / tileSize}.png`;

			const img = new Image();
			img.onload = () => {
				context.drawImage(img, tileX, tileY, tileSize, tileSize);
			};
			img.src = imgSrc;
		});
	}

	// Debugging output for initial values
	// console.log("Initial transform:", initialTransform);
	// console.log("Tile generator scale:", tileGenerator.scale());
	// console.log("Tile generator translate:", tileGenerator.translate());

	// // fetch data from api

	// // create map
	// import * as d3 from "d3";

	// // Get the device pixel ratio, falling back to 1.
	// const dpr = window.devicePixelRatio || 1;

	// const canvas = document.getElementById("chart") as HTMLCanvasElement;
	// const minimap = document.getElementById("minimap") as HTMLCanvasElement;
	// const horizon = document.getElementById("horizon") as HTMLImageElement;

	// const svgUrl = "/drawings.svg"; // Replace with the actual path to your SVG file
	// const horizonUrl = "/horizon.png";

	// const context = canvas.getContext("2d");
	// const img = new Image();
	// canvas.width = canvas.offsetWidth; // Set canvas width
	// canvas.height = canvas.offsetHeight; // Set canvas height

	// const miniCtx = minimap.getContext("2d");
	// let viewportWidth = (minimap.width / 6) * dpr;
	// let viewportHeight = (minimap.height / 6) * dpr;

	// const points = [
	// 	[100, 100],
	// 	[200, 200],
	// 	[300, 300],
	// ]; // Example points

	// // const voronoi = d3.Delaunay.from(points).voronoi([
	// // 	0,
	// // 	0,
	// // 	canvas.width,
	// // 	canvas.height,
	// // ]);

	// // Function to convert SVG to Canvas
	// async function loadSvgToCanvas(svgUrl: string, canvas: HTMLCanvasElement) {
	// 	const response = await fetch(svgUrl);
	// 	const svgText = await response.text();

	// 	const svgBlob = new Blob([svgText], {
	// 		type: "image/svg+xml;charset=utf-8",
	// 	});
	// 	const url = URL.createObjectURL(svgBlob);

	// 	img.onload = function () {
	// 		const ctx = canvas.getContext("2d");
	// 		if (!ctx) {
	// 			throw new Error("Unable to get canvas context");
	// 		}

	// 		// Adjust the canvas size for Retina displays
	// 		canvas.width = canvas.offsetWidth * dpr;
	// 		canvas.height = canvas.offsetHeight * dpr;

	// 		// Scale the context to ensure correct drawing dimensions.
	// 		ctx.scale(dpr, dpr);

	// 		// Now, draw the image at the "normal" size despite the canvas being larger.
	// 		ctx.drawImage(img, 0, 0, canvas.offsetWidth, canvas.offsetHeight);

	// 		// Minimap
	// 		minimap.width = canvas.offsetWidth / 4;
	// 		minimap.height = canvas.offsetHeight / 4;

	// 		// miniCtx.drawImage(img, 0, 0, minimap.width, minimap.height);

	// 		miniCtx.strokeStyle = "red";
	// 		miniCtx.strokeRect(0, 0, minimap.width, minimap.height);

	// 		URL.revokeObjectURL(url);
	// 	};

	// 	img.src = url;
	// }

	// async function loadHorizonToCanvas(horizonUrl, canvas) {
	// 	const context = canvas.getContext("2d");
	// 	const img = new Image();

	// 	img.onload = () => {
	// 		const x = 0; // X-coordinate to start drawing the image
	// 		const y = canvas.height - img.height; // Y-coordinate to position the image at the bottom
	// 		context.drawImage(img, x, y);
	// 	};

	// 	img.src = horizonUrl;
	// }

	// loadSvgToCanvas(svgUrl, canvas);
	// loadHorizonToCanvas(horizonUrl, canvas);

	// // Setup zoom behavior
	// const zoom = d3
	// 	.zoom()
	// 	.scaleExtent([0.5, 800]) // Zoom limits
	// 	.on("zoom", (event) => {
	// 		const transform = event.transform;

	// 		// Clear the canvas
	// 		context.clearRect(0, 0, canvas.width, canvas.height);

	// 		// Apply the transformation
	// 		context.save(); // Save the current context state
	// 		context.translate(transform.x, transform.y); // Apply translation
	// 		context.scale(transform.k, transform.k); // Apply scale

	// 		// Draw the image at (0, 0) since the transformation is already applied
	// 		context.drawImage(img, 0, 0, canvas.width / dpr, canvas.height / dpr);

	// 		// Draw Voronoi cells
	// 		// context.beginPath();
	// 		// voronoi.render(context);
	// 		// context.strokeStyle = "rgba(255, 0, 0, 0.5)"; // Example: red lines for Voronoi edges
	// 		// context.stroke();

	// 		// Calculate the new size of the viewportRect based on the zoom scale
	// 		const newViewportWidth = (viewportWidth / event.transform.k) * dpr;
	// 		const newViewportHeight = (viewportHeight / event.transform.k) * dpr;

	// 		// Calculate the new position of the viewportRect
	// 		// This assumes the top-left of the main canvas corresponds to (0,0) in minimap coordinates
	// 		const newX =
	// 			(-event.transform.x * minimap.width) / canvas.width / event.transform.k;
	// 		const newY =
	// 			(-event.transform.y * minimap.height) /
	// 			canvas.height /
	// 			event.transform.k;

	// 		// Redraw the minimap and viewportRect
	// 		miniCtx.clearRect(0, 0, minimap.width, minimap.height); // Clear the minimap
	// 		// miniCtx.drawImage(img, 0, 0, minimap.width, minimap.height); // Redraw the minimap image

	// 		// Draw the new viewportRect
	// 		miniCtx.strokeStyle = "red";
	// 		miniCtx.strokeRect(newX, newY, newViewportWidth, newViewportHeight);

	// 		context.restore(); // Restore the context to its original state
	// 	});

	// // Apply zoom behavior to the canvas
	// d3.select(canvas).call(zoom);
</script>
