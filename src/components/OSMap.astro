---
import Draw from "./Draw.svelte";

// dont prerender this component as we need to get fresh data from the api.
export const prerender = false;

// Map settings

// const polygons = await directus.request(
// 	readItems("polygons", {
// 		fields: ["id", "location", "price", { licenses: ["id"] }],
// 	}),
// );

// const drawings = await directus.request(
// 	readItems("drawings", {
// 		fields: ["id", "name", "location", "artist_credit", "image"],
// 	}),
// );

// intersection of a point with drawing polygons
// const intersects = await directus.request(
// 	readItems("drawings", {
// 		fields: ["*"],
// 		filter: {
// 			area: {
// 				_intersects: {
// 					type: "Feature",
// 					properties: {},
// 					geometry: {
// 						coordinates: [-66.09679179594478, -23.722487874932185],
// 						type: "Point",
// 					},
// 				},
// 			},
// 		},
// 	}),
// );
// console.log("INTERSECTION");
// console.log(intersects);

// intersection of a polygon with drawing polygons
// const response = await directus.items("Land").readByQuery({
// 	limit: 100,
// 	fields: ["id", "name", "center", "geometry"],
// 	filter: {
// 		center: {
// 			_intersects: {
// 				type: "Feature",
// 				geometry: {
// 					coordinates: [
// 						[
// 							[168.2947501099543, -17.723682144590242],
// 							[168.2947501099543, -17.727328428851507],
// 							[168.29840874403044, -17.727328428851507],
// 							[168.29840874403044, -17.723682144590242],
// 							[168.2947501099543, -17.723682144590242],
// 						],
// 					],
// 					type: "Polygon",
// 				},
// 			},
// 		},
// 	},
// });
---

<div
	class="w-full h-screen flex flex-col bg-blue-100 items-center justify-center relative"
>
	<div class="w-full h-full" id="map"></div>
	<div class="flex absolute right-0 bottom-0 w-full gap-4 p-4">
		<div class="w-[270px]"></div>
		<div
			class="bg-primary rounded-full grow shadow-cloud flex justify-center items-center relative"
		>
			<span class="opacity-50">Timeline</span>
			<div
				class="absolute left-1/4 flex justify-center items-center bg-white rounded-full border-primary border text-primary text-serif text-small h-7 w-7"
			>
				<span>C1</span>
			</div>
			<div class="absolute bg-white border-l border-white h-full left-24"></div>

			<div
				class="absolute left-6 flex justify-center items-center bg-white rounded-full border-primary border text-primary text-serif text-small h-7 w-7"
			>
				<span>C3</span>
			</div>
			<div
				class="absolute left-8 flex justify-center items-center bg-white rounded-full border-primary border text-primary text-serif text-small h-7 w-7"
			>
				<span>C2</span>
			</div>
		</div>
		<button class="button">Draw</button>
		<div class="shadow-cloud
			rounded-full
			w-11
			h-11"></div>
		<div class="shadow-cloud rounded-full w-11 h-11"></div>
		<label class="flex items-center cursor-pointer">
			<input
				id="themeToggle"
				type="checkbox"
				value="generate"
				class="sr-only peer"
			/>
			<div
				class="relative w-[46px] h-6 sm:w-[81px] sm:h-[45px] bg-primary shadow-cloud rounded-full peer peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full after:content-[''] after:absolute after:top-[2px] after:start-[3px] sm:after:top-[5px] sm:after:start-[6px] after:bg-white after:rounded-full after:w-5 after:h-5 sm:after:h-[35px] sm:after:w-[35px] after:transition-all"
			>
			</div>
			<span
				class="sr-only ms-3 text-sm font-medium text-gray-900 dark:text-gray-300"
				>Generate new cells mode toggle</span
			>
		</label>
	</div>
</div>

<script>
	// import "./style.css";
	import "ol/ol.css"; // Import OpenLayers CSS
	import { Map, View } from "ol";
	import TileLayer from "ol/layer/Tile";
	import XYZ from "ol/source/XYZ";
	import OverviewMap from "ol/control/OverviewMap";
	import { fromLonLat } from "ol/proj";
	import * as d3 from "d3";
	import { defaults as defaultControls } from "ol/control";

	// tile url
	// /tiles/${tileZ}/${tileX / tileSize}_${tileY / tileSize}.png

	const tileLayer = new TileLayer({
		source: new XYZ({
			url: "https://storage.googleapis.com/fairclouds_tiles/tiles/{z}/{x}_{y}.png", // Path to your tiles
			maxZoom: 12, // Adjust based on the max zoom level available in your tiles
			minZoom: 2,
			tileSize: [256, 256], // Size of your tiles, typically 256x256 or 512x512
			// Optionally define the extent and projection if necessary
			wrapX: false,
		}),
	});

	// Define the map with the XYZ tile source
	const map = new Map({
		target: "map",
		layers: [
			new TileLayer({
				source: new XYZ({
					url: "https://storage.googleapis.com/fairclouds_tiles/tiles_v2/{z}/{x}_{y}.png", // Path to your tiles
					maxZoom: 12, // Adjust based on the max zoom level available in your tiles
					minZoom: 2,
					tileSize: [256, 256], // Size of your tiles, typically 256x256 or 512x512
					// Optionally define the extent and projection if necessary
					wrapX: false,
				}),
			}),
		],
		view: new View({
			center: [0, 0], // Adjust based on your map's center
			zoom: 2, // Initial zoom level
			maxZoom: 12, // Maximum zoom level, should match maxZoom in XYZ source
			minZoom: 2,
			extent: [-20037508.34, -14537508.34, 20037508.34, 12537508.34],
		}),
		controls: defaultControls({ zoom: false }), // Disable zoom controls
	});

	// Add a minimap (OverviewMap control)
	const overviewMapControl = new OverviewMap({
		className: "ol-overviewmap ol-custom-overviewmap",
		layers: [
			new TileLayer({
				source: new XYZ({
					url: "https://storage.googleapis.com/fairclouds_tiles/tiles_v2/{z}/{x}_{y}.png", // Path to your tiles
					maxZoom: 12, // Adjust based on the max zoom level available in your tiles
					minZoom: 2,
					tileSize: [256, 256], // Size of your tiles, typically 256x256 or 512x512
					// Optionally define the extent and projection if necessary
					wrapX: false,
				}),
			}),
		],
		view: new View({
			center: [0, 0],
			zoom: 2,
			maxZoom: 2,
			extent: [-20037508.34, -20037508.34, 20037508.34, 20037508.34],
		}),
		collapsible: false,
	});
	map.addControl(overviewMapControl);

	// Generate 100 random geographic points
	const points = Array.from({ length: 3000 }, () => [
		-165 + Math.random() * 333, // Longitude between -120 and -60
		-28 + Math.random() * 82, // Latitude between 20 and 50
		Math.random() * 0.5 + 0.1,
	]);

	// 2. Create an overlay canvas for Voronoi
	// 2. Create an overlay canvas for Voronoi
	const overlayCanvas = document.createElement("canvas");
	const overlayContext = overlayCanvas.getContext("2d");
	overlayCanvas.style.position = "absolute";
	overlayCanvas.style.top = "0";
	overlayCanvas.style.left = "0";
	overlayCanvas.style.pointerEvents = "none";
	document.getElementById("map").appendChild(overlayCanvas);

	let voronoiDiagram;
	let delaunay;
	let projectedPoints;

	function calculateVoronoi() {
		projectedPoints = points
			.map((point) => {
				const coord = fromLonLat(point);
				return map.getPixelFromCoordinate(coord);
			})
			.filter((pixel) => pixel !== null);

		if (projectedPoints.length < 3) {
			console.error("Not enough points to calculate Voronoi diagram");
			return;
		}

		delaunay = d3.Delaunay.from(projectedPoints);
		voronoiDiagram = delaunay.voronoi([
			0,
			0,
			overlayCanvas.width,
			overlayCanvas.height,
		]);
	}

	function drawVoronoi(highlightedCellIndex = null) {
		if (!overlayContext || !voronoiDiagram) return;

		overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

		// Calculate the convex hull of the points
		const hullPoints = d3.polygonHull(projectedPoints);
		if (!hullPoints) return;

		// Clip the Voronoi diagram to the convex hull
		overlayContext.beginPath();
		overlayContext.moveTo(hullPoints[0][0], hullPoints[0][1]);
		for (let i = 1; i < hullPoints.length; i++) {
			overlayContext.lineTo(hullPoints[i][0], hullPoints[i][1]);
		}
		overlayContext.closePath();
		overlayContext.clip();

		// Draw the Voronoi diagram
		overlayContext.beginPath();
		voronoiDiagram.render(overlayContext);
		overlayContext.strokeStyle = "black";
		overlayContext.stroke();

		// Fill each cell with a white opaque background
		for (let i = 0; i < projectedPoints.length; i++) {
			const polygon = voronoiDiagram.cellPolygon(i);
			if (polygon) {
				overlayContext.beginPath();
				overlayContext.moveTo(polygon[0][0], polygon[0][1]);
				for (let j = 1; j < polygon.length; j++) {
					overlayContext.lineTo(polygon[j][0], polygon[j][1]);
				}
				overlayContext.closePath();
				overlayContext.fillStyle = `rgba(255, 255, 255, ${points[i][2]})`;
				overlayContext.fill();

				// Draw the cell border
				overlayContext.beginPath();
				overlayContext.moveTo(polygon[0][0], polygon[0][1]);
				for (let j = 1; j < polygon.length; j++) {
					overlayContext.lineTo(polygon[j][0], polygon[j][1]);
				}
				overlayContext.closePath();
			}
		}

		// Highlight the hovered cell
		if (highlightedCellIndex !== null) {
			const polygon = voronoiDiagram.cellPolygon(highlightedCellIndex);
			if (polygon) {
				overlayContext.beginPath();
				overlayContext.moveTo(polygon[0][0], polygon[0][1]);
				for (let j = 1; j < polygon.length; j++) {
					overlayContext.lineTo(polygon[j][0], polygon[j][1]);
				}
				overlayContext.closePath();
				overlayContext.fillStyle = "rgba(255, 255, 255, 0.8)";
				overlayContext.fill();
			}
		}
	}

	function resizeCanvas() {
		overlayCanvas.width = map.getSize()[0];
		overlayCanvas.height = map.getSize()[1];
	}

	// Initial render once map is rendered
	map.once("postrender", function () {
		calculateVoronoi();
		resizeCanvas();
		drawVoronoi();
	});

	// Redraw Voronoi on moveend events
	map.on("moveend", function () {
		resizeCanvas();
		drawVoronoi();
	});

	// Throttle function to limit the rate of function execution
	function throttle(func, limit) {
		let lastFunc;
		let lastRan;
		return function () {
			const context = this;
			const args = arguments;
			if (!lastRan) {
				func.apply(context, args);
				lastRan = Date.now();
			} else {
				clearTimeout(lastFunc);
				lastFunc = setTimeout(
					function () {
						if (Date.now() - lastRan >= limit) {
							func.apply(context, args);
							lastRan = Date.now();
						}
					},
					limit - (Date.now() - lastRan),
				);
			}
		};
	}

	// Add mousemove event listener to the overlay canvas for Voronoi interaction
	map.on(
		"pointermove",
		throttle((event) => {
			const mousePos = event.pixel;
			const index = delaunay.find(mousePos[0], mousePos[1]);
			drawVoronoi(index);
		}, 100),
	); // Adjust the throttle limit as needed
</script>
